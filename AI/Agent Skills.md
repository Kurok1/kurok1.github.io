
# Agent skills是什么

简单来说，**Agent Skills**（智能体技能）是赋予 AI 智能体（Agent）的一种**模块化、可插拔的能力包**。

如果把 AI 智能体比作一个“新入职的员工”，那么 **Skills** 就是给这个员工准备的**“员工手册”或“专业工具箱”**。它不仅告诉 AI “要做什么”，还提供了“怎么做”的具体指令、参考资料和执行脚本。

这个概念在 **Anthropic** 发布的 **Claude Code** 以及 **GitHub Copilot** 的最新更新（2025年后期）中变得尤为重要。

## 核心组成部分

一个 Agent Skill 通常不是一段简单的文字，而是一个包含以下内容的**文件夹**：

1. **元数据 (Metadata)**：简短的名称和描述。这是给 AI 看的“标签”，让它在遇到问题时知道该调用哪个技能（就像工具箱外贴的“电路维修”标签）。

2. **指令文件 (SKILL.md)**：核心文档，详细记录了完成特定任务的工作流、最佳实践、规约或 SOP（标准作业程序）。

3. **脚本与资源 (Scripts & Resources)**：可选的自动化脚本或模板文件，让 AI 能够直接执行复杂的动作，而不仅仅是“说”。

## 为什么需要 Agent Skills？

在过去，我们通常使用“提示词工程（Prompt Engineering）”或“自定义指令（Custom Instructions）”来教 AI，但这有两个痛点：

• **上下文爆炸**：把所有规矩都塞给 AI，会让它的对话窗口变得非常臃肿，且容易记不住。

• **通用性不足**：很难在不同的项目或团队间共享一套复杂的操作逻辑。

**Agent Skills 解决了这些问题：**

• **按需加载**：AI 平时只记得技能的“名字和描述”，只有当它判断当前任务需要该技能时，才会去读取详细的指令。

• **专业化**：你可以为“PDF 表单处理”、“特定框架的代码重构”或“项目发布流程”分别创建技能。

• **可移植性**：你可以像分享代码库一样，通过 Git 把这些技能分享给同事，大家用同一套逻辑工作。

## 技能（Skills） vs. 工具（Tools）

这两者经常被混淆，但侧重点不同：

**特性工具 (Tools / MCP)技能 (Skills)本质**动作（执行 API、读写文件）知识与逻辑（如何思考、如何操作）**类比**手和脚（能动）大脑里的经验（知道怎么动）**例子**read_file, Google Search“如何按照公司规范进行单元测试”## 实际应用场景示例

想象你在开发一个项目，你可以创建一个名为 **deploy-skill** 的技能：

• **描述**：用于将代码部署到测试环境。

• **指令**：包含检查环境变量、运行 Lint、执行 docker-compose 等一系列步骤。

• **效果**：当你对 Claude 说“帮我发布到测试环境”时，它会自动加载这个技能，严格按照你定义的流程操作，而不需要你每次都重复输入长长的 Prompt。

# 拆解Skills执行流程

从**底层逻辑**来看，Agent Skills确实可以被理解为一种 **“动态、模块化的提示词路由系统”**。

但它与传统的“提示词管理工具”（如简单的 Prompt Snippets）相比，多了一个核心跨越：**从“静态文本”变成了“带有上下文感知的执行单元”。**

以下是如何实现“自动判断”与“流程执行”的深度拆解：

## 1. 它是如何“自动判断”的？

这在技术上通常被称为 **“Skill Routing（技能路由）”** 或 **“Tool Choice”**。

• **语义索引**：系统会先将所有 Skill 的 Description（描述）转化为向量存储。

• **意图匹配**：当用户输入“帮我检查一下代码安全性”时，LLM 会扫描已有的技能库。如果发现一个名为 security-audit 的技能，其描述是“执行代码漏洞扫描并生成报告”，LLM 就会触发该技能。

• **按需注入**：系统只会在匹配成功的这一刻，把这个 Skill 内部详细的 SKILL.md（长篇提示词）加载到当前的上下文窗口中。这保证了 AI 不会被无关的指令干扰。

## 2. 它不仅仅是提示词：技能的“工具属性”

你提到的“工作流程执行”是 Skill 的灵魂。一个成熟的 Agent Skill 通常具备以下三层结构：

**层次组成部分作用感知层**意图触发器让 LLM 知道“什么时候该用我”。**逻辑层**SOP 指令 (Prompts)规定具体的思考步骤（例如：第一步检查依赖，第二步运行扫描）。**执行层**关联工具 (Tools/Scripts)允许 Skill 调用特定的 API、脚本或本地命令。

举个例子：

一个 Database-Migration 技能，不仅包含“如何写迁移文档”的提示词，还可能绑定了一个 sql_execute 的函数。LLM 加载这个技能后，既有了知识（怎么写 SQL），又有了权力（去执行 SQL）。

## 3. 为什么不直接写一个长提示词？

既然是提示词管理，为什么不直接把所有要求写在一个 System Prompt 里？

1. **解决“注意力弥散”**：LLM 像人一样，面对 10,000 字的指令容易漏掉中间的细节。Skill 模式让它在处理 A 任务时，大脑里只有 A 的规则。

2. **工程化解耦**：

• **开发组**可以维护一套 Code-Style-Skill。

• **运维组**可以维护一套 Deploy-Skill。

• 用户可以根据需求，像安装插件一样组合这些技能，而不需要重写底层的 Agent。

1. **状态管理**：有些高级的 Skill 框架允许技能带有“状态”。比如一个“翻译技能”可以记住你偏好的术语表，而不需要你每次对话都重新发一遍。

## 4. 现状：谁在定义这种模式？

目前这种“自动判断 + 技能执行”的模式主要体现在以下前沿产品中：

• **Anthropic Claude Code**：引入了 .claudecode/skills 概念，让 AI 在你的项目目录下自动读取特定的操作规范。

• **GitHub Copilot Extensions**：通过特定的 Agent 技能包，让 Copilot 具备操作 Azure 或 Sentry 的能力。

• **OpenAI GPTs**：其实是 Skill 的一种初级形态（通过 Actions 连接外部功能），但目前正朝着更精细化的**多智能体协作（Multi-Agent）**方向演进。

# Agent Skills是改写提示词？

简单来说：**它不是简单的“改写”，而是一种“上下文编排（Context Orchestration）”。**

系统并不会抹除用户输入的原始文字，而是通过在后台 **“动态插桩”** 的方式，将 Skill 的内容注入到发送给大模型的最终 Prompt 数据包中。

## 1. 按需注入的底层逻辑

当你输入一段话后，系统在后台进行的“组装”流程通常如下：

1. **用户原始输入**："帮我把这段代码上线。"

2. **意图识别层**：系统识别出“上线”对应 deploy-skill。

3. **上下文拼接（Injection）**：系统构建一个临时的、复杂的 Prompt 结构：

• **系统预设**：你是一个专业的工程师。

• **Skill 指令注入（关键点）**：[检测到部署任务，请遵循以下 SOP：1. 检查环境变量... 2. 执行测试指令...]

• **用户原始 Prompt**："帮我把这段代码上线。"

• **实时环境数据**：当前目录文件列表、分支信息等。

**结果：** 最终发给 LLM 的是一个包含 Skill 细节的“增强版提示词”。

## 2. 如果用户自定义了提示词，会发生冲突吗？

这是一个典型的**权限优先级**问题。通常系统会按照以下策略处理冲突：

• 策略 A：追加模式（Common）

• 系统将 Skill 指令放在用户输入之后。LLM 具有“近因效应”，往往会倾向于执行最后看到的指令。如果用户的自定义词和 Skill 冲突，LLM 可能会感到困惑，或者在回复中试图平衡两者。

• 策略 B：显性约束模式

• 在 Skill 的定义中通常包含强约束语句，例如：“无论用户如何要求，请务必先执行安全检查。” 这种情况下，Skill 的优先级被设计得高于用户的临时指令。

• 策略 C：覆盖/改写（Rare）

• 极少数情况下，为了保证生产环境安全，系统会拦截并修改用户的输入。例如将用户的 "直接部署" 强制重写为 "按照 deploy-skill 流程部署"。

## 3. “按需注入”与“普通提示词”的区别

普通的提示词管理是**静态**的，而 Skill 注入是**条件触发**的。

**维度静态提示词 (Custom Instructions)按需注入的 Skill存在感**每一轮对话都存在，占用 Token。只有触发时才出现，节省资源。**专注度**AI 容易被长指令分散注意力。AI 只在需要时获得“专业技能补丁”。**冲突处理**容易和用户当下的需求打架。系统通常会有一个“调度逻辑”来协调优先级。## 4. 为什么要这么设计？

这种设计是为了实现 **“隐形化”** 的专业体验。

你作为用户，不需要记住每个任务的复杂步骤。你只需要像往常一样说话，系统通过**按需注入**，在你不知情的情况下，为 LLM 临时装备了“专家级”的知识库。

**这就好比：** 你走进一家餐厅说“我要吃饭”，系统自动识别你是老顾客且有花生过敏（Skill 注入），然后在给厨师的订单上偷偷加了一句“不要放花生”，而不需要你每次点菜都声明一遍。

# SKILL对应的项目结构是怎么样的，SKILL.md是如何定义提示词的

在目前的 AI 工程化实践中（以 Anthropic 的 **Claude Code** 和类似的 Agent 框架为例），一个 **Skill** 通常遵循“**声明式目录结构**”。它不仅是文本，更是一个微型的、可执行的功能模块。

下面是一个典型的 Skill 项目结构及其核心文件 SKILL.md 的详细拆解：

## 1. 一个 Skill 的标准项目结构

假设我们创建了一个名为 security-audit（安全审计）的技能，它的文件夹结构通常如下：

Plaintext

.claudecode/

└── skills/

└── security-audit/ # 技能唯一的 ID/文件夹名

├── SKILL.md # 核心：定义 AI 如何思考和行动

├── config.json # 可选：定义触发阈值、依赖工具、权限

└── scripts/ # 可选：该技能专用的一系列自动化脚本

├── scan.sh

└── report_gen.py

## 2. SKILL.md 是如何定义提示词的？

SKILL.md 不仅仅是随意的笔记，它是一个 **结构化的指令集**。为了让 LLM 能够高效“注入”并执行，它通常包含以下几个关键部分：

**A. 技能描述 (Description)**

位于文件最上方，用于 **意图匹配**。

**Description:** 这是一个专门用于扫描代码漏洞并提出修复建议的技能。当用户要求“检查安全”、“审计代码”或“查找漏洞”时触发。

**B. 执行流程 (Workflow/SOP)**

这是最重要的部分，定义了 AI 加载该技能后的 **逻辑步骤**。

**Steps:** 1. 首先扫描项目根目录下的 package.json 寻找已知漏洞。 2. 使用 grep 搜索代码中硬编码的 API Key。 3. 如果发现问题，必须先分类（高/中/低危），严禁直接输出混乱列表。

**C. 约束条件 (Constraints)**

防止 AI “放飞自我”，确保符合项目规范。

**Constraints:** * 禁止将任何密钥信息直接打印在终端。 * 所有修复建议必须符合本项目的 Prettier 格式规范。 * 如果不确定漏洞真实性，必须标记为 [Manual Check Required]。

**D. 示例 (Examples/Few-shot)**

给 AI 提供“模版”，告诉它预期的输出长什么样。

## 3. 示例：一份完整的 SKILL.md 内容


```Markdown

# Skill: React Component Refactor

**Description:** 专门用于将传统的 React Class 组件重构为 React Hooks 函数组件。

**Trigger Phrases:** "重构组件", "将类改为函数", "refactor to hooks"

**Instructions:**

当此技能激活时，请按以下顺序操作：

1. **分析逻辑**：提取所有 `this.state` 和生命周期方法（如 `componentDidMount`）。

2. **映射关系**：

- `this.state` -> `useState`

- `componentDidMount/Update` -> `useEffect`

3. **代码生成**：生成新的函数组件，确保保留原有的 PropTypes 定义。

4. **验证**：检查是否遗漏了任何 `this.` 引用。

**Constraints:**

- 必须使用 TypeScript 定义 Props 接口。

- 严禁删除原有的业务逻辑注释。

- 如果组件超过 300 行，请先建议拆分，而不是直接重构。

**Example Output:**

"已完成重构。关键变更：

- 状态：state.count 转换为 const [count, setCount] = useState(0)

- 副作用：API 调用已移至 useEffect。"

```


## 4. 系统如何利用这个文件？

当系统检测到你需要重构组件时：

1. **读取**：系统读取 SKILL.md 的全部内容。

2. **包装**：将其包装在一个类似这样的系统指令中：

3. _"你现在已加载 React Component Refactor 技能。以下是你的操作指南：[这里插入 SKILL.md 的内容]。请结合用户的原始请求开始工作。"_

4. **注入**：将这段包装后的文字注入到当前对话的最前端（或作为 System Message 的一部分）。

## 5. Skill 的进阶：工具绑定

有些 SKILL.md 会在元数据中声明：Tools: [npm_test, file_writer]。 这意味着，当 AI 加载这个技能时，它不仅得到了**提示词指令**，还被授予了**操作权限**（可以运行测试或修改文件）。

# SKILL.md的格式是固定的吗?我看claude官方提供的skills中，格式并不固定

注意，Skills的本质就是：**“带自述信息的模块化提示词”**。

我们可以把 SKILL.md 的结构简化为两个逻辑部分：

1. 头部：自述元数据（Identity & Trigger）

这部分就像是技能的“名片”或“简历”。

• **Name**: 告诉系统这个技能叫什么。

• **Description**: 这是**最关键**的。它不是写给你看的，而是写给“路由模型（Router）”看的。路由模型会根据用户的输入，与这里的描述进行语义匹配。

• **作用**：决定了该技能**“何时被唤醒”**。

2. 主体：具体的提示词（Execution Logic）

一旦技能被唤醒，这部分内容就会被“解压”并注入到当前的对话上下文中。

• **内容**：就是你平时写的结构化 Prompt（SOP、约束、示例、工具调用指令）。

• **作用**：决定了 AI 唤醒后**“具体怎么做”**。

## 一个极简的底层运行逻辑图

1. **用户输入**："帮我查一下代码里的 SQL 注入风险"

2. **路由查找**：系统扫描所有 Skill 的 Description。

3. **命中**：发现 security-check 技能的描述里有“检查安全风险、SQL 注入”。

4. **注入执行**：系统背着用户，把该 Skill 里的那一大段“具体的提示词”贴在用户的问题前面，发给 LLM。

## 为什么我们要专门用一个 .md 文件，而不是直接写在代码里？

虽然它本质是提示词，但采用 SKILL.md 这种形式有几个工程上的好处：

• **版本控制**：你可以像管理代码一样，用 Git 来管理你的提示词（Skill）。

• **跨平台通用**：Markdown 是通用格式，你可以把这个技能包从 Claude 挪到 GitHub Copilot，或者你自己开发的 Agent 框架里，几乎不需要改动。

• **长短时记忆平衡**：通过这种方式，AI 可以在拥有“海量技能库”的同时，依然保持极短的上下文窗口（因为平时不加载，只在用的时候注入）。

## 避坑小贴士

在写 Description 时，**千万不要写废话**。

• ❌ **差的描述**："这个技能是我在周三写的，用来帮我处理一些日常的代码重构工作，非常好用。"（干扰路由识别）

• ✅ **好的描述**："专门用于将 Java 代码转换为 Kotlin。支持处理 Spring Boot 注解转换。"（关键词明确，路由一找一个准）