# Redis总结

## Redis是如何保证高性能的 {id="redis_1"}

Redis的大部分操作都是直接在内存上操作的，这是它实现高性能的主要原因。因此redis的性能瓶颈集中在网络io上，在io处理方面，redis采用了多路复用机，这使得其能在网络io操作中能并发处理大量的请求，实现高吞吐率。

另一方面，redis并非完全是单线程模型，他的其他功能，比如持久化，异步删除，集群数据同步等，还是由额外的线程进行执行的。

在Redis6.0之后，在io处理方面引入了多线程，但是注意到是仅在读取客户端io请求方面是用多线程处理的，实际命令的执行还是在主线程执行。



## Redis可能出现的慢操作

1. **rehash** redis本维护了一个全局的哈希表维护键和值。而当键值对越来越多时，由于哈希冲突导致某些哈希桶的长度过长，因此需要重构整个哈希表用于平衡各个哈希桶的大小。rehash的过程是发生在主线程的
2. **集合操作** 集合的遍历操作



## AOF日志 {id="aof_1"}

类似于MySQL的binlog中的statement格式，记录客户端执行的每一条命令作为持久化依据。注意，该操作并不在主线程中执行，因此并不会阻塞主线程的正常操作。AOF回写有三种模式：

| 配置项   | 写回时机           | 优点                         | 缺点                           |
| -------- | ------------------ | ---------------------------- | ------------------------------ |
| Always   | 同步回写           | 可靠性最高，数据基本不会丢失 | 每条命令都要写盘，性能影响太大 |
| Everysec | 每秒回写           | 性能优于同步回写             | 宕机时丢失一秒内数据           |
| NO       | 操作系统控制的回写 | 性能好                       | 宕机时丢失数据较多             |

## AOF文件重写 {id="aof_2"}

考虑到AOF文件过大的问题，redis提供了重写机制，即将同一key的命令进行覆盖，同一key只保留最新的一条命令



## AOF文件重写会阻塞主线程吗

并不会。重写过程是由后台子进程 bgrewriteaof 来完成的。但是考虑到重写过程中，主线程仍在对外提供服务，为了不丢失重写过程中执行的命令，在重写过程中，正在执行的命令会写入到缓冲区，等到重写完成后，会与缓冲区内新写入到命令，一起写入到新的AOF文件之中。